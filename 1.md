#  51115113

# 作業一

## 解題說明

本題要求實作一個「遞迴函式」與一個「非遞迴演算法」，以計算 Ackermann 函數 $A(m, n)$。

## 解題策略

1. 使用條件判斷式處理三種不同的輸入情況。
2. 遞迴版本直接對應數學定義。
3. 非遞迴版本需利用堆疊（stack）模擬函式呼叫順序，避免系統呼叫堆疊溢位。

## 程式實作

### 遞迴版本

```cpp
#include <iostream>
using namespace std;

int ackermann(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ackermann(m - 1, 1);
    else
        return ackermann(m - 1, ackermann(m, n - 1));
}

int main() {
    cout << ackermann(2, 3) << endl;  // 輸出：9
}
```
### 非遞迴版本

```cpp
#include <iostream>
#include <stack>
using namespace std;

int ackermann_nonrecursive(int m, int n) {
    stack<int> stk;
    stk.push(m);
    while (!stk.empty()) {
        m = stk.top(); stk.pop();
        if (m == 0) {
            n = n + 1;
        } else if (n == 0) {
            stk.push(m - 1);
            n = 1;
        } else {
            stk.push(m - 1);
            stk.push(m);
            n = n - 1;
        }
    }
    return n;
}

int main() {
    cout << ackermann_nonrecursive(2, 3) << endl;  // 輸出：9
}
```
## 效能分析
1. 時間複雜度：阿克曼函數的成長速度超越所有原始遞迴函數，無法以傳統多項式方式估算，僅能視為超指數級別。
2. 空間複雜度：遞迴版：$O(\text{遞迴深度})$，易導致 Stack Overflow。
   非遞迴版：使用手動 stack 管理，能避免系統堆疊限制。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $(m, n)$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $(0, 2)$     | 3        | 3        |
| 測試二   | $(1, 0)$     | 2        | 2        |
| 測試三   | $(2, 2)$     | 7        | 7        |
| 測試四   | $(3, 2)$     | 29       | 29       |
| 測試五   | $(3, 3)$     | 61       | 61       |

### 編譯與執行指令(遞迴)

$ g++ -std=c++17 -o 123 123.cpp
$ ./123
9

### 結論

1阿克曼函數能有效測試遞迴處理能力。
2程式可正確處理小範圍輸入，符合數學定義。
3測試涵蓋不同範圍的輸入，驗證實作正確性與效率限制。

## 申論及開發報告

### 選擇遞迴的原因

1. 遞迴本身非常適合處理具有「自我重複結構」的問題，像是連加這類問題，其數學公 式本身就具備遞迴性質，這種寫法非常直觀地對應到程式的遞迴結構，能讓程式碼與數學概念對齊，提升可讀性。
2. 若使用迴圈寫法，雖然在效能上可能更好，但需要額外引入變數、控制條件與疊代機制。而遞迴版本只需數行，邏輯也更精簡，不需記錄狀態，只要將問題不斷縮小即可。
3. 在設計遞迴函式時，可以直接在最前面判斷輸入是否非法（如 n < 0），一旦發現問題立即拋出錯誤，而不必進入多層的邏輯。這樣的結構清楚又安全，能避免不合理的輸入繼續執行下去
